<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SPF Record Checker</title>
  <style>
    :root{
      --accent:#6A1B9A;
      --accent-2:#AB47BC;
      --bg:linear-gradient(135deg,#f3e5f5 0%,#e1bee7 100%);
      --card:#EDE7F6;
      --muted:#666;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:#222}
    header{background:linear-gradient(135deg,var(--accent) 0%,var(--accent-2) 100%);padding:24px;text-align:center;color:#fff;border-radius:0 0 12px 12px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
    header h1{margin:0;font-size:1.5rem}
    header p{margin:6px 0 0;font-size:0.95rem;opacity:0.95}
    main{max-width:920px;margin:28px auto;padding:18px}
    .card{background:var(--card);padding:18px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.06);border:2px solid var(--accent-2)}
    form{display:grid;grid-template-columns:1fr 240px;gap:12px;align-items:end}
    label{display:block;font-weight:600;color:var(--accent);margin-bottom:6px}
    .field{display:flex;flex-direction:column}
    input[type="text"], select{padding:12px;border-radius:8px;border:1px solid #caa7dd;font-size:1rem;background:#fff}
    button{background:var(--accent);color:#fff;border:none;padding:12px 16px;border-radius:8px;cursor:pointer;font-weight:600}
    button[disabled]{opacity:0.6;cursor:not-allowed}
    .controls{display:flex;gap:8px}
    .result{margin-top:14px;padding:12px;border-radius:8px;background:#fff;border:1px solid #e6e0ea}
    .success{color:green;background:#e6f7ea}
    .failure{color:#8b0000;background:#fdecef}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{padding:8px;border:1px solid #eee;text-align:left;font-size:0.95rem}
    th{background:#f4f7fb;color:var(--accent)}
    .small{font-size:0.9rem;color:var(--muted)}
    .note{margin-top:10px;font-size:0.9rem;color:#444}
    pre{white-space:pre-wrap;word-wrap:break-word;margin:0}
    .spinner{display:inline-block;width:18px;height:18px;border:3px solid rgba(255,255,255,0.2);border-top-color:rgba(255,255,255,0.9);border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-left:8px}
    @keyframes spin{to{transform:rotate(360deg)}}
    @media(max-width:820px){form{grid-template-columns:1fr;}.controls{justify-content:space-between}}
  </style>
</head>
<body>
  <header>
    <h1>SPF Record Checker</h1>
    <p>Enter a domain and IP to check whether the IP is allowed by the domain's SPF. Works over HTTPS (suitable for GitHub Pages).</p>
  </header>

  <main>
    <section class="card">
      <h2 style="margin-top:0">Check SPF Record</h2>

      <form id="spfForm" onsubmit="return false;">
        <div class="field">
          <label for="domain">Domain name</label>
          <input id="domain" type="text" placeholder="example.com" autocomplete="off" />
          <div class="small">Tip: don't include protocol (no http://). You can use a public resolver fallback if one fails.</div>
        </div>

        <div class="field">
          <label for="ip">IP address to check</label>
          <input id="ip" type="text" placeholder="192.0.2.1 or 2001:db8::1" autocomplete="off" />
        </div>

        <div style="grid-column:1 / -1;display:flex;gap:8px;margin-top:6px;align-items:center">
          <div style="flex:1">
            <label for="resolver">Resolver (fallback order)</label>
            <select id="resolver">
              <option value="cloudflare">Cloudflare (cloudflare-dns.com)</option>
              <option value="google">Google (dns.google)</option>
            </select>
          </div>

          <div class="controls">
            <button id="checkButton" type="button">Check SPF</button>
            <button id="clearButton" type="button" style="background:#888">Clear</button>
          </div>
        </div>
      </form>

      <div id="result" class="result" aria-live="polite"></div>

    <!--  <div class="note">
        This tool queries public DNS-over-HTTPS resolvers (CORS-enabled). If you host this page on GitHub Pages it will run correctly. The checker understands ip4:/ip6: mechanisms and basic include: redirects (recursive up to 5 levels).
      -->
      </div>
    </section>
  </main>

  <script>
    // --- Utilities ---
    function stripQuotes(s) {
      if (!s) return s;
      // Remove paired leading/trailing quotes and join if multiple quoted segments
      // Example Cloudflare TXT: "\"v=spf1 include:_spf.example.com ~all\""
      // Or sometimes: "v=spf1" (without quotes)
      return s.replace(/^"(.+)"$/, '$1');
    }

    // IPv4 helpers
    function ipv4ToInt(ip) {
      const parts = ip.trim().split('.');
      if (parts.length !== 4) return null;
      const nums = parts.map(p => {
        if (!/^\d+$/.test(p)) return null;
        const n = Number(p);
        return n >=0 && n <=255 ? n : null;
      });
      if (nums.includes(null)) return null;
      return ((nums[0]<<24)>>>0) + (nums[1]<<16) + (nums[2]<<8) + nums[3];
    }
    function ipv4InCidr(ip, network, prefix) {
      const i = ipv4ToInt(ip);
      const n = ipv4ToInt(network);
      if (i===null||n===null) return false;
      const mask = prefix === 0 ? 0 : (~((1 << (32 - prefix)) - 1)) >>> 0;
      return (i & mask) === (n & mask);
    }

    // IPv6 helpers (basic)
    function expandIPv6(addr) {
      // returns array of 8 groups of 16-bit hex strings, or null
      if (!addr) return null;
      // handle embedded IPv4
      const ipv4match = addr.match(/(.*:)(\d+\.\d+\.\d+\.\d+)$/);
      let ipv4part = null;
      if (ipv4match) {
        addr = ipv4match[1] + '0.0.0.0'; // placeholder, we'll replace later
        ipv4part = ipv4match[2];
      }
      const parts = addr.split('::');
      if (parts.length > 2) return null;
      let left = parts[0] ? parts[0].split(':') : [];
      let right = parts[1] ? parts[1].split(':') : [];
      // replace empty strings
      if (left.length === 1 && left[0] === '') left = [];
      if (right.length === 1 && right[0] === '') right = [];
      const missing = 8 - (left.length + right.length);
      if (missing < 0) return null;
      const mid = new Array(missing).fill('0');
      const full = left.concat(mid, right);
      if (ipv4part) {
        // replace last two groups with IPv4 converted to hex
        const v4 = ipv4part.split('.').map(Number);
        if (v4.length !== 4) return null;
        const high = ((v4[0]<<8) | v4[1]).toString(16);
        const low = ((v4[2]<<8) | v4[3]).toString(16);
        full[6] = high;
        full[7] = low;
      }
      if (full.length !== 8) return null;
      return full.map(g => g ? g.padStart(4,'0') : '0000');
    }
    function ipv6ToBigInt(addr) {
      const parts = expandIPv6(addr);
      if (!parts) return null;
      let acc = 0n;
      for (const p of parts) {
        acc = (acc << 16n) + BigInt(parseInt(p, 16));
      }
      return acc;
    }
    function ipv6InCidr(ip, network, prefix) {
      const ipb = ipv6ToBigInt(ip);
      const nb = ipv6ToBigInt(network);
      if (ipb === null || nb === null) return false;
      if (prefix < 0 || prefix > 128) return false;
      if (prefix === 0) return true;
      const shift = 128n - BigInt(prefix);
      return (ipb >> shift) === (nb >> shift);
    }

    // Parse mechanisms from an SPF string
    function parseSpfMechanisms(spf) {
      // spf is something like 'v=spf1 ip4:192.0.2.0/24 include:example.com -all'
      const tokens = spf.trim().split(/\s+/);
      // drop leading 'v=spf1'
      if (tokens.length && tokens[0].toLowerCase() === 'v=spf1') tokens.shift();
      return tokens;
    }

    // Resolve TXT records via DNS-over-HTTPS provider
    async function dohTxt(domain, provider='cloudflare') {
      const name = encodeURIComponent(domain);
      let url;
      if (provider === 'google') {
        url = `https://dns.google/resolve?name=${name}&type=TXT`;
      } else {
        // cloudflare default
        url = `https://cloudflare-dns.com/dns-query?name=${name}&type=TXT`;
      }
      const res = await fetch(url, { headers: {'Accept':'application/dns-json'} });
      if (!res.ok) throw new Error('DNS resolver returned ' + res.status + ' ' + res.statusText);
      const json = await res.json();
      return json;
    }

    // Recursively check includes up to depth
    async function checkSpfForIp(domain, ip, provider, depth=0, visited=new Set()) {
      if (depth > 5) return {found:false, reason:'Max recursion depth reached'};
      if (visited.has(domain.toLowerCase())) return {found:false, reason:'Already checked (loop)'};
      visited.add(domain.toLowerCase());

      // try provider first, then fallback to other
      const providers = provider === 'google' ? ['google','cloudflare'] : ['cloudflare','google'];
      let json;
      let lastError = null;
      for (const p of providers) {
        try {
          json = await dohTxt(domain, p);
          break;
        } catch (e) {
          lastError = e;
        }
      }
      if (!json) return {found:false, reason:'DNS query failed', error:lastError};

      const answers = Array.isArray(json.Answer) ? json.Answer.map(a => a.data) : [];
      // join multi-segment TXT entries (some resolvers return quoted segments)
      const txts = answers.map(a => {
        // Cloudflare returns with quotes around string segments; Google returns raw.
        // Remove wrapping quotes and unescape if necessary
        let s = a;
        // If it's like: "\"v=spf1 include:...\""
        s = s.replace(/\s*"\s*/g, '"'); // normalize extra spaces around quotes
        // remove leading/trailing double quotes for entire string
        if (s.startsWith('"') && s.endsWith('"')) s = s.slice(1,-1);
        // remove paired quotes that surround segments like "part1""part2" => part1part2
        s = s.replace(/""/g, '');
        return s;
      });

      // find SPF records
      const spfs = txts.filter(t => t.trim().toLowerCase().startsWith('v=spf1'));
      if (spfs.length === 0) {
        return {found:false, reason:'No SPF (v=spf1) TXT record found', txts};
      }

      // evaluate each spf record (usually one)
      for (const spfRaw of spfs) {
        const spf = spfRaw.trim();
        const mechanisms = parseSpfMechanisms(spf);

        // Check mechanisms sequentially; if any mechanism matches, return success with detail
        for (const mech of mechanisms) {
          const m = mech.trim();
          // qualifiers (+ ? - ~) optionally prefix mechanism; remove it for parsing
          let qualifier = '+';
          let body = m;
          if (/^[\+\-\~\?].+/.test(m)) {
            qualifier = m[0];
            body = m.slice(1);
          }

          if (body.startsWith('ip4:')) {
            const value = body.slice(4);
            const [network, prefix] = value.includes('/') ? value.split('/') : [value, '32'];
            const p = Number(prefix);
            if (isNaN(p)) continue;
            if (ipv4InCidr(ip, network, p)) {
              return {found:true, mechanism:m, qualifier, matchedIn:domain, spf, txts};
            }
          } else if (body.startsWith('ip6:')) {
            const value = body.slice(4);
            const [network, prefix] = value.includes('/') ? value.split('/') : [value, '128'];
            const p = Number(prefix);
            try {
              if (ipv6InCidr(ip, network, p)) {
                return {found:true, mechanism:m, qualifier, matchedIn:domain, spf, txts};
              }
            } catch (e) {
              // ignore parse errors
            }
          } else if (body.startsWith('include:')) {
            const includeDomain = body.slice(8);
            // recursively check include
            const res = await checkSpfForIp(includeDomain, ip, provider, depth+1, visited);
            if (res && res.found) {
              // annotate that it matched in included domain
              res.matchedVia = `include:${includeDomain} (from ${domain})`;
              return res;
            }
            // otherwise continue to next mechanism
          } else if (body === 'all') {
            // all applies to any IP (qualifier matters). If qualifier is + or neutral, it's pass.
            if (qualifier === '+' || qualifier === '?') {
              return {found:true, mechanism:m, qualifier, matchedIn:domain, spf, txts};
            } else {
              // -all or ~all indicates fail or softfail -> not allowed depending on qualifier
              return {found:false, mechanism:m, qualifier, matchedIn:domain, spf, txts, reason:'matched all (fail/softfail)'} ;
            }
          } else {
            // other mechanisms: a, mx, ptr, exists, redirect= â€” not fully implemented as they require extra lookups
            // For 'a' or 'mx' we could optionally resolve, but we keep it simple and skip.
          }
        }
      }

      // none matched directly; check 'redirect=' modifier if present
      for (const spfRaw of spfs) {
        const spf = spfRaw.trim();
        const m = spf.match(/redirect=(\S+)/i);
        if (m) {
          const redirectDomain = m[1];
          const res = await checkSpfForIp(redirectDomain, ip, provider, depth+1, visited);
          if (res && res.found) return res;
        }
      }

      return {found:false, reason:'No matching mechanism found in SPF', txts};
    }

    // --- UI wiring ---
    const domainEl = document.getElementById('domain');
    const ipEl = document.getElementById('ip');
    const resultEl = document.getElementById('result');
    const checkButton = document.getElementById('checkButton');
    const clearButton = document.getElementById('clearButton');
    const resolverSel = document.getElementById('resolver');

    function setLoading(on) {
      if (on) {
        checkButton.disabled = true;
        checkButton.innerHTML = 'Checking <span class="spinner" aria-hidden="true"></span>';
      } else {
        checkButton.disabled = false;
        checkButton.textContent = 'Check SPF';
      }
    }

    checkButton.addEventListener('click', async () => {
      const domain = (domainEl.value || '').trim();
      const ip = (ipEl.value || '').trim();
      const provider = resolverSel.value;
      resultEl.innerHTML = '';
      if (!domain) {
        resultEl.className = 'result failure';
        resultEl.innerHTML = '<strong>Please enter a domain.</strong>';
        return;
      }
      if (!ip) {
        resultEl.className = 'result failure';
        resultEl.innerHTML = '<strong>Please enter an IP address.</strong>';
        return;
      }

      setLoading(true);
      try {
        const res = await checkSpfForIp(domain, ip, provider, 0, new Set());
        if (res.error) {
          resultEl.className = 'result failure';
          resultEl.innerHTML = `<strong>Lookup failed:</strong> ${escapeHtml(String(res.error.message || res.error))}`;
          console.error(res.error);
        } else if (res.found) {
          resultEl.className = 'result success';
          const from = res.matchedVia ? `${escapeHtml(res.matchedVia)}` : `in ${escapeHtml(res.matchedIn || domain)}`;
          resultEl.innerHTML = `<strong>PASS:</strong> The IP <code>${escapeHtml(ip)}</code> is allowed by SPF (mechanism: <code>${escapeHtml(res.mechanism || '')}</code>) ${from}.<br><details style="margin-top:8px"><summary>SPF record used</summary><pre>${escapeHtml(res.spf || '')}</pre></details>`;
        } else {
          resultEl.className = 'result failure';
          let details = '';
          if (res.txts && res.txts.length) {
            details = `<details style="margin-top:8px"><summary>Found TXT/SPF entries</summary><pre>${escapeHtml(res.txts.join('\\n'))}</pre></details>`;
          }
          const reason = res.reason ? ` (${escapeHtml(String(res.reason))})` : '';
          resultEl.innerHTML = `<strong>NO MATCH:</strong> The IP <code>${escapeHtml(ip)}</code> is not explicitly allowed by the SPF record${reason}.${details}`;
        }
      } catch (err) {
        resultEl.className = 'result failure';
        resultEl.innerHTML = `<strong>Error:</strong> ${escapeHtml(err.message || String(err))}`;
        console.error(err);
      } finally {
        setLoading(false);
      }
    });

    clearButton.addEventListener('click', () => {
      domainEl.value = '';
      ipEl.value = '';
      resultEl.innerHTML = '';
      resultEl.className = 'result';
    });

    // small helper to escape HTML for insertion
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // expose a simple usability convenience: press Enter on inputs to trigger check
    [domainEl, ipEl].forEach(el => {
      el.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          checkButton.click();
        }
      });
    });

  </script>
</body>
</html>
